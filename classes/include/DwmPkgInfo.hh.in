//===========================================================================
// @(#) $DwmPath$
//===========================================================================
//  Copyright (c) Daniel W. McRobb 2025
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The names of the authors and copyright holders may not be used to
//     endorse or promote products derived from this software without
//     specific prior written permission.
//
//  IN NO EVENT SHALL DANIEL W. MCROBB BE LIABLE TO ANY PARTY FOR
//  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
//  INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF DANIEL W. MCROBB HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
//  DAMAGE.
//
//  THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND
//  DANIEL W. MCROBB HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
//  UPDATES, ENHANCEMENTS, OR MODIFICATIONS. DANIEL W. MCROBB MAKES NO
//  REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND, EITHER
//  IMPLIED OR EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE,
//  OR THAT THE USE OF THIS SOFTWARE WILL NOT INFRINGE ANY PATENT,
//  TRADEMARK OR OTHER RIGHTS.
//===========================================================================

//---------------------------------------------------------------------------
//!  \file DwmPkgInfo.hh
//!  \author Daniel W. McRobb
//!  \brief Dwm::Pkg::Info class template and associated support code
//---------------------------------------------------------------------------

#ifndef _DWMPKGINFO_HH_
#define _DWMPKGINFO_HH_

#include <cstdint>
#include <cstdlib>
#include <cstring>

#include "DwmPkgSegmentedLiteral.hh"

//----------------------------------------------------------------------------
//!  Just some macros for UTF-8 encodings of some unicode characters
//----------------------------------------------------------------------------
#define DWM_PKG_SYM_ALARM_CLOCK       "\xE2\x8F\xB0"            // alarm clock
#define DWM_PKG_SYM_ALIEN             "\xF0\x9F\x91\xBD"        // alien
#define DWM_PKG_SYM_BLUE_CIRCLE       "\xF0\x9F\x94\xB5"
#define DWM_PKG_SYM_BOOKS             "\xF0\x9F\x93\x9A"
#define DWM_PKG_SYM_CALENDAR          "\xF0\x9F\x93\x86"  // tear-off Calendar
#define DWM_PKG_SYM_CAUTION_SIGN      "\xE2\x98\xA1"
#define DWM_PKG_SYM_CHANGE_TETRA      "\xF0\x9D\x8C\xA1"  // change tetragram
#define DWM_PKG_SYM_CHECK_MARK        "\xE2\x9C\x93"
#define DWM_PKG_SYM_CONSTRUCT_WORKER  "\xF0\x9F\x91\xB7"
#define DWM_PKG_SYM_CONSTRUCT_ZONE    "\xF0\x9F\x9A\xA7"
#define DWM_PKG_SYM_COPYRIGHT         "\xC2\xA9\xEF\xB8\x8F "
#define DWM_PKG_SYM_CYCLONE           "\xF0\x9F\x8C\x80"        // cyclone
#define DWM_PKG_SYM_DOT               "\xE2\x97\x8F"            // dot
#define DWM_PKG_SYM_FILE_FOLDER       "\xF0\x9F\x93\x81"
#define DWM_PKG_SYM_FULLHASH          "\xEF\xBC\x83"
#define DWM_PKG_SYM_GEAR              "\xE2\x9A\x99"            // gear
#define DWM_PKG_SYM_GHOST             "\xF0\x9F\x91\xBB"
#define DWM_PKG_SYM_HEAVY_CHECK       "\xE2\x9C\x94"
#define DWM_PKG_SYM_HEAVY_EXCL        "\xE2\x9D\x97"
#define DWM_PKG_SYM_JACKOLANTERN      "\xF0\x9F\x8E\x83"  // jack-o-lantern
#define DWM_PKG_SYM_OPEN_BOOK         "\xF0\x9F\x93\x96"
#define DWM_PKG_SYM_OPEN_FOLDER       "\xF0\x9F\x93\x82"
#define DWM_PKG_SYM_PACKAGE           "\xF0\x9F\x93\xA6"  // Package
#define DWM_PKG_SYM_PAGE              "\xF0\x9F\x93\x84"
#define DWM_PKG_SYM_ROBOT             "\xF0\x9F\xA4\x96"        // robot emoji
#define DWM_PKG_SYM_ROCKET            "\xF0\x9F\x9A\x80"        // rocket
#define DWM_PKG_SYM_WARNING_SIGN      "\xE2\x9A\xA0"
#define DWM_PKG_SYM_WHITE_CHECK       "\xE2\x9C\x85"
#define DWM_PKG_SYM_RP_TRIANGLE       "\xE2\x96\xB6" // right-pointing triangle

//----------------------------------------------------------------------------
//!  The three characters I use for 'status'.  Development, release candidate
//!  or release.
//----------------------------------------------------------------------------
#define DWM_PKG_STATUS_DEV  DWM_PKG_SYM_HEAVY_EXCL
#define DWM_PKG_STATUS_RC   DWM_PKG_SYM_CONSTRUCT_WORKER
#define	DWM_PKG_STATUS_REL  DWM_PKG_SYM_WHITE_CHECK

//----------------------------------------------------------------------------
//!  The characters I use for 'package type', one of 'header-only library',
//!  'library', 'executable' or 'documentation'.
//----------------------------------------------------------------------------
#define DWM_PKG_TYPE_HDR  DWM_PKG_SYM_FULLHASH
#define DWM_PKG_TYPE_LIB  DWM_PKG_SYM_BOOKS
#define DWM_PKG_TYPE_EXE  DWM_PKG_SYM_ROBOT
#define DWM_PKG_TYPE_DOC  DWM_PKG_SYM_PAGE

//----------------------------------------------------------------------------
//!  Symbol to place before the 'other' field.  I prefer nothing here and
//!  will likely remove this.
//----------------------------------------------------------------------------
#define DWM_PKG_SYM_OTHER ""

//----------------------------------------------------------------------------
//!  Delimiter, which I'll likely remove and always use a fixed single space.
//----------------------------------------------------------------------------
#define DWM_PKG_DELIM " "

//----------------------------------------------------------------------------
//!  DWM_PKG_MK_LINE_ARG(__LINE__) can be used to get a string literal of
//!  __LINE__.
//----------------------------------------------------------------------------
#define DWM_PKG_MK_LINE_ARG(x) DWM_PKG_MK_LINE_ARG2(x)
#define DWM_PKG_MK_LINE_ARG2(x) #x

namespace Dwm {

  namespace Pkg {

    //------------------------------------------------------------------------
    //!  Class template to hold package information using an encapsulated
    //!  SegmentedLiteral to build a compile-time string so we have a
    //!  contiguous character array that can be found in a binary (object
    //!  file, library or executable).  An instance of this template
    //!  would normally be declared inline constexpr in a header file
    //!  that is visible to all translation units.  The linker takes care
    //!  of eliminating duplicates.  You probably also want to mark your
    //!  instance with __attribute__((used)) so the linker doesn't remove
    //!  it due to no apparent use.
    //------------------------------------------------------------------------
    template <std::size_t P, std::size_t S, std::size_t N, std::size_t V,
              std::size_t C, std::size_t O>
    class Info
      : public SegmentedLiteral<1,10,
                                SegmentedLiteralChars_v<sizeof(DWM_PKG_DELIM),
                                                        sizeof("@(#)"),P,S,
                                                        N,V,
                                                        sizeof(DWM_PKG_SYM_COPYRIGHT),
                                                        C, sizeof(__DATE__),
                                                        sizeof(DWM_PKG_SYM_OTHER),
                                                        O>>
    {
    public:
      using MyLiteral =
        SegmentedLiteral<1,10,
                         SegmentedLiteralChars_v<sizeof(DWM_PKG_DELIM),
                                                 sizeof("@(#)"),P,S,
                                                 N,V,
                                                 sizeof(DWM_PKG_SYM_COPYRIGHT),
                                                 C, sizeof(__DATE__),
                                                 sizeof(DWM_PKG_SYM_OTHER),O>>;
      
      //----------------------------------------------------------------------
      //!  Construct from a given package type @c pkgtype (see the
      //!  @c DWM_PKG_TYPE_* macros above), package @c status (see the
      //!  @c DWM_PKG_STATUS_* macros above), package @c name, package
      //!  @c version, package @c copyright and finally any @c other
      //!  information.  All arguments are string literals.
      //----------------------------------------------------------------------
      consteval Info(const char (&pkgtype)[P], const char (&status)[S],
                     const char (&name)[N], const char (&version)[V],
                     const char (&cpyright)[C], const char (&other)[O])
          : MyLiteral(DWM_PKG_DELIM, "@(#)", pkgtype, status, name, version,
                      DWM_PKG_SYM_COPYRIGHT, cpyright, __DATE__,
                      DWM_PKG_SYM_OTHER, other)
      {}

      //----------------------------------------------------------------------
      //!  
      //----------------------------------------------------------------------
      template <std::size_t PI, std::size_t SI, std::size_t NI,
                std::size_t VI, std::size_t CI, std::size_t OI>
      constexpr bool operator ==
      (const Info<PI,SI,NI,VI,CI,OI> & info) const noexcept
      {
        return (this->view() == info.view());
      }

      //----------------------------------------------------------------------
      //!  
      //----------------------------------------------------------------------
      template <std::size_t PI, std::size_t SI, std::size_t NI,
                std::size_t VI, std::size_t CI, std::size_t OI>
      constexpr bool operator <
      (const Info<PI,SI,NI,VI,CI,OI> & info) const noexcept
      {
        return (this->view() < info.view());
      }
      
      //----------------------------------------------------------------------
      //!  Returns the package type.
      //----------------------------------------------------------------------
      constexpr std::string_view type() const noexcept
      { return this->nth(1); }

      //----------------------------------------------------------------------
      //!  Returns the package status.
      //----------------------------------------------------------------------
      constexpr std::string_view status() const noexcept
      { return this->nth(2); }

      //----------------------------------------------------------------------
      //!  Returns the package name.
      //----------------------------------------------------------------------
      constexpr std::string_view name() const noexcept
      { return this->nth(3); }

      //----------------------------------------------------------------------
      //!  Returns the package version.
      //----------------------------------------------------------------------
      constexpr std::string_view version() const noexcept
      { return this->nth(4); }
      
      //----------------------------------------------------------------------
      //!  Returns the package copyright.
      //----------------------------------------------------------------------
      constexpr std::string_view copyright() const noexcept
      { return this->nth(6); }
      
      //----------------------------------------------------------------------
      //!  Returns the date the object was compiled.
      //----------------------------------------------------------------------
      constexpr std::string_view date() const noexcept
      { return this->nth(7); }

      //----------------------------------------------------------------------
      //!  Returns the 'other' data.
      //----------------------------------------------------------------------
      constexpr std::string_view other() const noexcept
      { return this->nth(9); }
      
      //----------------------------------------------------------------------
      //!  Returns a string holding the package information in JSON format.
      //----------------------------------------------------------------------
      constexpr std::string as_json() const noexcept
      {
        return "{\"type\": \"" + std::string(type())
          + "\", \"name\": \"" + std::string(name())
          + "\", \"status\": \"" + std::string(status())
          + "\", \"version\": \"" + std::string(version())
          + "\", \"copyright\": \"" + std::string(copyright())
          + "\", \"date\": \"" + std::string(date())
          + "\", \"other\": \"" + std::string(other())
          + "\", \"id\": \""
          + std::string(this->view())
          + "\"}";
      }

      //----------------------------------------------------------------------
      //!  Returns a view of the buffer from the start of the 'type' segment
      //!  to the end (skipping over the prefix).
      //----------------------------------------------------------------------
      constexpr std::string_view data_view() const noexcept
      {
        auto  slv = this->view();
        std::size_t  len = slv.size() - (type().size() + 1);
        return std::string_view(type().data(), len);
      }

    };

    inline constexpr const Info __attribute__((used))
    info(DWM_PKG_TYPE_HDR, @DWM_PKG_STATUS@, "libDwmPkg", "@DWM_VERSION@",
         "Daniel McRobb " DWM_PKG_SYM_GHOST, "mcplex.net");
    
  }  // namespace Pkg

}  // namespace Dwm

#endif  // _DWMPKGINFO_HH_
